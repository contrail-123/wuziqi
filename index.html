<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>äº”å­æ£‹äººæœºå¯¹æˆ˜ï¼ˆè€æŸ¯contrailï¼‰</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0d9b5;
            font-family: Arial, sans-serif;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(15, 40px);
            gap: 1px;
            background: #8b4513;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }
        .cell {
            background: #f0d9b5;
            cursor: pointer;
            position: relative;
        }
        .piece {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            position: absolute;
            top: 5px;
            left: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .black { background: #000; }
        .white { background: #fff; border: 1px solid #666; }
        #status {
            margin: 20px;
            font-size: 24px;
            color: #634832;
        }
        button {
            padding: 10px 25px;
            font-size: 16px;
            background: #8b4513;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: 0.3s;
        }
        button:hover { background: #634832; }
        .mode-buttons {
            margin: 15px 0;
            display: flex;
            gap: 20px;
        }
        .mode-btn {
            padding: 10px 20px;
            background: #634832;
            border-radius: 20px;
            cursor: pointer;
            color: white;
        }
        .mode-btn.active {
            background: #8b4513;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <h1>äº”å­æ£‹äººæœºå¯¹æˆ˜ï¼ˆæ”»é˜²å¢å¼ºç‰ˆï¼‰</h1>
    <div class="mode-buttons">
        <button class="mode-btn active" onclick="setMode('black')">æ‰§é»‘å…ˆè¡Œ</button>
        <button class="mode-btn" onclick="setMode('white')">æ‰§ç™½åè¡Œ</button>
    </div>
    <div id="board"></div>
    <div id="status">å½“å‰è½®åˆ°ï¼šé»‘æ£‹</div>
    <button onclick="resetGame()">é‡æ–°å¼€å§‹</button>

    <script>
        const boardSize = 15;
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        let currentPlayer = 'black';
        let gameOver = false;
        let boardState = Array.from({length: boardSize}, () => Array(boardSize).fill(null));
        let humanSide = 'black';
        let aiThinking = false;

        // AIå‚æ•°
        const MAX_THINK_TIME = 1500;
        const WIN_SCORE = 1000000;
        const patternWeights = {
            FIVE: WIN_SCORE,
            LIVE_FOUR: 500000,   // æé«˜æ´»å››æƒé‡
            DORMANT_FOUR: 100000, // æé«˜çœ å››æƒé‡
            LIVE_THREE: 5000,    // æé«˜æ´»ä¸‰æƒé‡
            DORMANT_THREE: 1000,
            LIVE_TWO: 200,
            DORMANT_TWO: 50
        };

        class EnhancedGomokuAI {
            constructor() {
                this.cache = new Map();
                this.startTime = 0;
                this.bestMove = null;
                this.defenseMoves = new Set();
                this.attackMoves = new Set();
            }

            getBestMove(board) {
                this.startTime = Date.now();
                this.bestMove = null;
                let depth = 1;
                
                while (depth <= 3 && !this.timeout()) {
                    try {
                        this.alphaBetaSearch(this.copyBoard(board), depth);
                        depth++;
                    } catch (e) {
                        break;
                    }
                }
                return this.bestMove || this.fallbackMove(board);
            }

            alphaBetaSearch(board, depth) {
                let alpha = -Infinity;
                let beta = Infinity;
                const moves = this.genPriorityMoves(board);
                
                for (const [x, y] of moves) {
                    if (this.timeout()) throw new Error('Timeout');
                    
                    const newBoard = this.copyBoard(board);
                    newBoard[x][y] = 'white';
                    const score = this.minimax(newBoard, depth-1, alpha, beta, false);
                    
                    if (score > alpha) {
                        alpha = score;
                        this.bestMove = [x, y];
                    }
                }
            }

            minimax(board, depth, alpha, beta, isMaximizing) {
                if (this.timeout()) throw new Error('Timeout');
                
                const winner = this.quickEvaluate(board);
                if (winner !== null) {
                    return winner === 'white' ? WIN_SCORE : -WIN_SCORE;
                }
                if (depth === 0) return this.fastEvaluate(board);

                const moves = this.genPriorityMoves(board);
                let bestVal = isMaximizing ? -Infinity : Infinity;

                for (const [x, y] of moves) {
                    const newBoard = this.copyBoard(board);
                    newBoard[x][y] = isMaximizing ? 'white' : 'black';
                    const value = this.minimax(newBoard, depth-1, alpha, beta, !isMaximizing);

                    if (isMaximizing) {
                        bestVal = Math.max(bestVal, value);
                        alpha = Math.max(alpha, value);
                    } else {
                        bestVal = Math.min(bestVal, value);
                        beta = Math.min(beta, value);
                    }
                    
                    if (beta <= alpha) break;
                }

                return bestVal;
            }

            genPriorityMoves(board) {
                this.defenseMoves.clear();
                this.attackMoves.clear();
                
                // æ£€æµ‹é»‘æ£‹å¨èƒï¼ˆé˜²å¾¡ï¼‰
                this.findThreats(board, 'black', 'defense');
                // æ£€æµ‹ç™½æ£‹æœºä¼šï¼ˆè¿›æ”»ï¼‰
                this.findThreats(board, 'white', 'attack');

                const existingMoves = this.getExistingMoves(board);
                const allMoves = new Set([...existingMoves, ...this.defenseMoves, ...this.attackMoves]);
                
                if (allMoves.size === 0) return [[7,7]];
                
                return Array.from(allMoves)
                    .map(s => s.split(',').map(Number))
                    .sort((a, b) => {
                        const aAttack = this.attackMoves.has(`${a[0]},${a[1]}`) ? 0 : 1;
                        const bAttack = this.attackMoves.has(`${b[0]},${b[1]}`) ? 0 : 1;
                        const aDefense = this.defenseMoves.has(`${a[0]},${a[1]}`) ? 0 : 2;
                        const bDefense = this.defenseMoves.has(`${b[0]},${b[1]}`) ? 0 : 2;
                        
                        return aAttack - bAttack || aDefense - bDefense || 
                               this.positionValue(a) - this.positionValue(b);
                    });
            }

            findThreats(board, targetColor, mode) {
                for (let x = 0; x < 15; x++) {
                    for (let y = 0; y < 15; y++) {
                        if (board[x][y] === targetColor) {
                            this.checkThreatsInAllDirections(board, x, y, targetColor, mode);
                        }
                    }
                }
            }

            checkThreatsInAllDirections(board, x, y, color, mode) {
                const directions = [[1,0],[0,1],[1,1],[1,-1]];
                directions.forEach(([dx, dy]) => {
                    let leftCount = 0, rightCount = 0;
                    
                    // å‘å³æ£€æŸ¥
                    let cx = x + dx, cy = y + dy;
                    while (cx >= 0 && cx < 15 && cy >= 0 && cy < 15 && board[cx][cy] === color) {
                        rightCount++;
                        cx += dx;
                        cy += dy;
                    }
                    const rightOpen = cx >= 0 && cx < 15 && cy >= 0 && cy < 15 && !board[cx][cy];

                    // å‘å·¦æ£€æŸ¥
                    cx = x - dx;
                    cy = y - dy;
                    while (cx >= 0 && cx < 15 && cy >= 0 && cy < 15 && board[cx][cy] === color) {
                        leftCount++;
                        cx -= dx;
                        cy -= dy;
                    }
                    const leftOpen = cx >= 0 && cx < 15 && cy >= 0 && cy < 15 && !board[cx][cy];

                    const total = leftCount + rightCount + 1;

                    // è¿›æ”»æ¨¡å¼æ£€æµ‹
                    if (mode === 'attack' && color === 'white') {
                        if (total === 4) {
                            if (rightOpen) this.addAttackPoint(x + dx * (rightCount + 1), y + dy * (rightCount + 1));
                            if (leftOpen) this.addAttackPoint(x - dx * (leftCount + 1), y - dy * (leftCount + 1));
                        }
                        if (total === 3) {
                            if (leftOpen && rightOpen) {
                                this.addAttackPoint(x + dx, y + dy);
                                this.addAttackPoint(x - dx, y - dy);
                            } else if (leftOpen) {
                                this.addAttackPoint(x - dx * (leftCount + 1), y - dy * (leftCount + 1));
                            } else if (rightOpen) {
                                this.addAttackPoint(x + dx * (rightCount + 1), y + dy * (rightCount + 1));
                            }
                        }
                    }

                    // é˜²å¾¡æ¨¡å¼æ£€æµ‹
                    if (mode === 'defense' && color === 'black') {
                        if (total === 4) {
                            if (rightOpen) this.addDefensePoint(x + dx * (rightCount + 1), y + dy * (rightCount + 1));
                            if (leftOpen) this.addDefensePoint(x - dx * (leftCount + 1), y - dy * (leftCount + 1));
                        }
                        if (total === 3) {
                            if (leftOpen && rightOpen) {
                                this.addDefensePoint(x + dx, y + dy);
                                this.addDefensePoint(x - dx, y - dy);
                            } else if (leftOpen) {
                                this.addDefensePoint(x - dx * (leftCount + 1), y - dy * (leftCount + 1));
                            } else if (rightOpen) {
                                this.addDefensePoint(x + dx * (rightCount + 1), y + dy * (rightCount + 1));
                            }
                        }
                    }
                });
            }

            addDefensePoint(x, y) {
                if (x >=0 && x <15 && y >=0 && y <15 && !boardState[x][y]) {
                    this.defenseMoves.add(`${x},${y}`);
                }
            }

            addAttackPoint(x, y) {
                if (x >=0 && x <15 && y >=0 && y <15 && !boardState[x][y]) {
                    this.attackMoves.add(`${x},${y}`);
                }
            }

            getExistingMoves(board) {
                const moves = new Set();
                for (let x=0; x<15; x++) {
                    for (let y=0; y<15; y++) {
                        if (board[x][y]) {
                            for (let dx=-2; dx<=2; dx++) {
                                for (let dy=-2; dy<=2; dy++) {
                                    const nx = x+dx, ny = y+dy;
                                    if (nx>=0 && nx<15 && ny>=0 && ny<15 && !board[nx][ny]) {
                                        moves.add(`${nx},${ny}`);
                                    }
                                }
                            }
                        }
                    }
                }
                return moves;
            }

            positionValue([x,y]) {
                const center = 7;
                return Math.abs(x - center) + Math.abs(y - center);
            }

            fastEvaluate(board) {
                let score = 0;
                for (let x=0; x<15; x++) {
                    for (let y=0; y<15; y++) {
                        if (board[x][y]) {
                            const isAI = board[x][y] === 'white';
                            for (const dir of [[1,0],[0,1],[1,1],[1,-1]]) {
                                const pattern = this.simplePatternCheck(board, x, y, dir);
                                const value = patternWeights[pattern] || 0;
                                score += isAI ? value : -value;
                            }
                        }
                    }
                }
                return score;
            }

            simplePatternCheck(board, x, y, [dx, dy]) {
                if (!board[x][y]) return null;
                let count = 1;
                let openEnds = 0;

                // æ­£å‘æ£€æŸ¥
                let cx = x + dx, cy = y + dy;
                while (cx >=0 && cx <15 && cy >=0 && cy <15 && board[cx][cy] === board[x][y]) {
                    count++;
                    cx += dx;
                    cy += dy;
                }
                if (cx >=0 && cx <15 && cy >=0 && cy <15 && !board[cx][cy]) openEnds++;

                // åå‘æ£€æŸ¥
                cx = x - dx;
                cy = y - dy;
                while (cx >=0 && cx <15 && cy >=0 && cy <15 && board[cx][cy] === board[x][y]) {
                    count++;
                    cx -= dx;
                    cy -= dy;
                }
                if (cx >=0 && cx <15 && cy >=0 && cy <15 && !board[cx][cy]) openEnds++;

                if (count >=5) return 'FIVE';
                if (count ===4) return openEnds >0 ? 'DORMANT_FOUR' : null;
                if (count ===3) return openEnds ===2 ? 'LIVE_THREE' : openEnds ===1 ? 'DORMANT_THREE' : null;
                if (count ===2) return openEnds >=1 ? 'LIVE_TWO' : null;
                return null;
            }

            quickEvaluate(board) {
                for (let x=0; x<15; x++) {
                    for (let y=0; y<15; y++) {
                        if (board[x][y] && this.checkWin(board, x, y)) {
                            return board[x][y];
                        }
                    }
                }
                return null;
            }

            checkWin(board, x, y) {
                const directions = [[1,0],[0,1],[1,1],[1,-1]];
                for (const [dx, dy] of directions) {
                    let count = 1;
                    for (let i=1; i<5; i++) {
                        const nx = x + dx*i, ny = y + dy*i;
                        if (nx<0||nx>=15||ny<0||ny>=15||board[nx][ny]!==board[x][y]) break;
                        count++;
                    }
                    for (let i=1; i<5; i++) {
                        const nx = x - dx*i, ny = y - dy*i;
                        if (nx<0||nx>=15||ny<0||ny>=15||board[nx][ny]!==board[x][y]) break;
                        count++;
                    }
                    if (count >=5) return true;
                }
                return false;
            }

            timeout() {
                return Date.now() - this.startTime > MAX_THINK_TIME;
            }

            copyBoard(board) {
                return board.map(row => [...row]);
            }

            fallbackMove(board) {
                for (let x=0; x<15; x++) {
                    for (let y=0; y<15; y++) {
                        if (!board[x][y]) return [x,y];
                    }
                }
                return [7,7];
            }
        }

        const aiEngine = new EnhancedGomokuAI();

        // åˆå§‹åŒ–æ£‹ç›˜
        function initBoard() {
            boardElement.innerHTML = '';
            for (let i=0; i<boardSize; i++) {
                for (let j=0; j<boardSize; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = i;
                    cell.dataset.y = j;
                    cell.addEventListener('click', handleClick);
                    boardElement.appendChild(cell);
                }
            }
        }

        function handleClick(e) {
            if (gameOver || aiThinking) return;
            if (currentPlayer !== humanSide) return;
            
            const x = parseInt(e.target.dataset.x);
            const y = parseInt(e.target.dataset.y);
            
            if (!boardState[x][y]) {
                placePiece(x, y);
                if (!gameOver) setTimeout(computerTurnCheck, 50);
            }
        }

        function placePiece(x, y) {
            const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
            const piece = document.createElement('div');
            piece.className = `piece ${currentPlayer}`;
            cell.appendChild(piece);
            boardState[x][y] = currentPlayer;

            if (checkWin(x, y)) {
                statusElement.innerHTML = `ğŸ‰ ${currentPlayer === 'black' ? 'é»‘æ£‹' : 'ç™½æ£‹'}è·èƒœï¼`;
                gameOver = true;
            } else {
                currentPlayer = currentPlayer === 'black' ? 'white' : 'black';
                statusElement.textContent = `å½“å‰è½®åˆ°ï¼š${currentPlayer === 'black' ? 'é»‘æ£‹' : 'ç™½æ£‹'}`;
            }
        }

        function computerTurnCheck() {
            if (!gameOver && currentPlayer !== humanSide) {
                aiThinking = true;
                setTimeout(computerMove, 100);
            }
        }

        function computerMove() {
            const move = aiEngine.getBestMove(boardState);
            if (move) placePiece(move[0], move[1]);
            aiThinking = false;
        }

        function checkWin(x, y) {
            const directions = [[1,0],[0,1],[1,1],[1,-1]];
            for (const [dx, dy] of directions) {
                let count = 1;
                for (let i=1; i<5; i++) {
                    let nx = x + dx*i, ny = y + dy*i;
                    if (nx<0||nx>=15||ny<0||ny>=15||boardState[nx][ny]!==currentPlayer) break;
                    count++;
                }
                for (let i=1; i<5; i++) {
                    let nx = x - dx*i, ny = y - dy*i;
                    if (nx<0||nx>=15||ny<0||ny>=15||boardState[nx][ny]!==currentPlayer) break;
                    count++;
                }
                if (count >=5) return true;
            }
            return false;
        }

        function setMode(side) {
            humanSide = side;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            resetGame();
        }

        function resetGame() {
            boardState = Array.from({length: boardSize}, () => Array(boardSize).fill(null));
            currentPlayer = 'black';
            gameOver = false;
            statusElement.textContent = 'å½“å‰è½®åˆ°ï¼šé»‘æ£‹';
            document.querySelectorAll('.piece').forEach(p => p.remove());
            if (humanSide !== currentPlayer) setTimeout(computerMove, 500);
        }

        initBoard();
    </script>
</body>
</html>
